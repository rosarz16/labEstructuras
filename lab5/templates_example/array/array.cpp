//////////////////////////////////////////////////////////////////////////////////////////////////
//#pragma implementation
//////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////
//include files
////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
#include "exception.hh"
#include <algorithm>
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////
namespace prima{
////////////////////////////////////////////////////////////////////
//Static Function Members
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
int array<T,N>::size(){
	return N;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::size_type array<T,N>::max_size(){
	 return N;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool array<T,N>::empty(){
	return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//Operator Overloading
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
array<T,N>& array<T,N>::operator=(const array<T,N>& right){
	if( this!=&right ){
		std::copy(right.begin(),right.end(),begin());
	}
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
template <typename T1>
array<T,N>& array<T,N>::operator=(const array<T1,N>& right){
	std::copy(right.begin(),right.end(),begin());
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
const T& array<T,N>::operator[](const int right) const{
	ASSERT( 0<=right && right<N ,"operator[]","request out of range");
	return m_data[right];
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
T& array<T,N>::operator[](const int right){
	ASSERT( 0<=right && right<N ,"operator[]","request out of range");
	return m_data[right];
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//Iterators
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::const_iterator array<T,N>::begin() const{
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::const_iterator array<T,N>::end() const{
	return m_data+N;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::iterator array<T,N>::begin(){
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::iterator array<T,N>::end(){
	return m_data+N;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::const_reverse_iterator array<T,N>::rbegin() const{
	return const_reverse_iterator( end() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::const_reverse_iterator array<T,N>::rend() const{
	return const_reverse_iterator( begin() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::reverse_iterator array<T,N>::rbegin(){
	return reverse_iterator( end() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::reverse_iterator array<T,N>::rend(){
	return reverse_iterator( begin() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::const_iterator array<T,N>::last() const{
	return m_data+N-1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
typename array<T,N>::iterator array<T,N>::last(){
	return m_data+N-1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//Administratives
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
const T& array<T,N>::front() const{
	return m_data[0];
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
const T& array<T,N>::back() const{
	return m_data[N-1];
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
T& array<T,N>::front(){
	return m_data[0];
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
T& array<T,N>::back(){
	return m_data[N-1];
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
void array<T,N>::print(std::ostream& os, const std::string separator, const std::string b, const std::string e) const{
	os << b;
	const_iterator last_element = last();
	for(const_iterator i=begin(); i!=last_element; ++i){
		os << *i << separator;
	}
	os << *last_element;
	os << e;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
void array<T,N>::print4char(std::ostream& os, const std::string separator, const std::string b, const std::string e) const{
	os << b;
	const_iterator last_element = last();
	for(const_iterator i=begin(); i!=last_element; ++i){
		os << static_cast<int>(*i) << separator;
	}
	os << static_cast<int>(*last_element);
	os << e;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
array<T,N>& array<T,N>::assign(const T right){
	std::fill_n(m_data,N,right);
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
array<T,N>& array<T,N>::reverse(){
	std::reverse(begin(),end());
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
void array<T,N>::swap(array<T,N>& right){
	//The result of swap_ranges() is undefined if the two ranges [start, finish) and [start2, start2 + (finish1 - start1)) overlap
	if( this!=&right ){
		std::swap_ranges(begin(),end(),right.begin());
	}
	else{
		//TODO: this swap should not throw and it has to be rewritten
		throw Exception(__FILE__,__LINE__,"swap","overlaping range");
	}
	return;
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//Properties
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool array<T,N>::has(const T right) const{
	return ( end() != std::find(begin(),end(),right) );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool array<T,N>::has(const array<T,N>& right) const{
	return ( end() != std::find_first_of(begin(),end(),right.begin(),right.end()) );
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//External Funtions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//Printing
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
std::ostream& operator<<(std::ostream& os, const array<T,N>& right){
	right.print(os,", ","(",")");
	return os;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <int N>
std::ostream& operator<<(std::ostream& os, const array<unsigned char,N>& right){
	right.print4char(os,", ","(",")");
	return os;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <int N>
std::ostream& operator<<(std::ostream& os, const array<signed char,N>& right){
	right.print4char(os,", ","(",")");
	return os;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <int N>
std::ostream& operator<<(std::ostream& os, const array<char,N>& right){
	right.print4char(os,", ","(",")");
	return os;
}
////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////
//Operator Overloading
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator==(const array<T,N>& a, const array<T,N>& b){
	return std::equal(a.begin(),a.end(),b.begin());
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator!=(const array<T,N>& a, const array<T,N>& b){
	return ! (a==b);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator<(const array<T,N>& a, const array<T,N>& b){
	return std::lexicographical_compare(a.begin(),a.end(),b.begin(),b.end());
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator>(const array<T,N>& a, const array<T,N>& b){
	return (b < a);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator<=(const array<T,N>& a, const array<T,N>& b){
	return ! (b < a);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator>=(const array<T,N>& a, const array<T,N>& b){
	return ! (a < b);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator==(const array<T,N>& right, const T value){
	return ( right.begin()==std::search_n(right.begin(), right.end(), N, value) );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator!=(const array<T,N>& right, const T value){
	return ! ( right == value );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator<(const array<T,N>& right, const T value){
	for(typename array<T,N>::const_iterator i=right.begin(); i!=right.end(); ++i){
		if(*i >= value){
			return false;
		}
	}
	return true;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator>(const array<T,N>& right, const T value){
	for(typename array<T,N>::const_iterator i=right.begin(); i!=right.end(); ++i){
		if(*i <= value){
			return false;
		}
	}
	return true;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator<=(const array<T,N>& right, const T value){
	return ! (right > value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator>=(const array<T,N>& right, const T value){
	return ! (right < value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator==(const T value, const array<T,N>& right){
	return ( right == value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator!=(const T value, const array<T,N>& right){
	return ! ( right == value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator<(const T value, const array<T,N>& right){
	return ( right > value );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator>(const T value, const array<T,N>& right){
	return ( right < value );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator<=(const T value, const array<T,N>& right){
	return (right >= value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T, int N>
bool operator>=(const T value, const array<T,N>& right){
	return (right <= value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////











} //namespace prima
////////////////////////////////////////////////////////////////////////////////////////////////////
