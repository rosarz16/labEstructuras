//////////////////////////////////////////////////////////////////////////////////////////////////
//#pragma implementation
//////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//include files
////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
#include "exception.hh"
//////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
namespace prima{
////////////////////////////////////////////////////////////////////
//Static Function Members
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
int array<T,1>::size(){
	return 1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::size_type array<T,1>::max_size(){
	 return 1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool array<T,1>::empty(){
	return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//Operator Overloading
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
array<T,1>& array<T,1>::operator=(const array<T,1>& right){
	m_data = right.m_data;
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
template <typename T1>
array<T,1>& array<T,1>::operator=(const array<T1,1>& right){
	m_data = right[0]; //the compiler may produce a warning
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
const T& array<T,1>::operator[](const int right) const{
	ASSERT(0==right,"operator[]","request out of range");
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
T& array<T,1>::operator[](const int right){
	ASSERT(0==right,"operator[]","request out of range");
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//Iterators
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::const_iterator array<T,1>::begin() const{
	return &m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::const_iterator array<T,1>::end() const{
	return &m_data+1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename  array<T,1>::iterator array<T,1>::begin(){
	return &m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename  array<T,1>::iterator array<T,1>::end(){
	return &m_data+1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::const_reverse_iterator array<T,1>::rbegin() const{
	return const_reverse_iterator( end() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::const_reverse_iterator array<T,1>::rend() const{
	return const_reverse_iterator( begin() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::reverse_iterator array<T,1>::rbegin(){
	return reverse_iterator( end() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::reverse_iterator array<T,1>::rend(){
	return reverse_iterator( begin() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename array<T,1>::const_iterator array<T,1>::last() const{
	return &m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
typename  array<T,1>::iterator array<T,1>::last(){
	return &m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////









////////////////////////////////////////////////////////////////////
//Administratives
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
void array<T,1>::print(std::ostream& os, const std::string b, const std::string e) const{
	os << b << m_data << e;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
array<T,1>& array<T,1>::assign(const T right){
	m_data = right;
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
array<T,1>& array<T,1>::reverse(){
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
void array<T,1>::swap(array<T,1>& right){
	value_type tmp =  m_data;
	m_data = right.m_data;
	right.m_data = tmp;
	return;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
const T& array<T,1>::front() const{
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
const T& array<T,1>::back() const{
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
T& array<T,1>::front(){
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
T& array<T,1>::back(){
	return m_data;
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//Properties
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool array<T,1>::has(const T right) const{
	return ( m_data==right );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool array<T,1>::has(const array<T,1>& right) const{
	return ( m_data==right.m_data );
}
////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////
//External Functions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
std::ostream& operator<<(std::ostream& os, const array<T,1>& right){
	right.print(os);
	return os;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const array<T,1>& a, const array<T,1>& b){
	//TODO: try std::equal for floats -Wfloat-equal
	return ( a.front()==b.front() );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const array<T,1>& a, const array<T,1>& b){
	return (a.front() < b.front());
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const array<T,1>& right, const T value){
	return ( right.front()==value );
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const array<T,1>& right, const T value){
	return (right.front() < value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>(const array<T,1>& right, const T value){
	return (right.front()>value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////










} //namespace prima
////////////////////////////////////////////////////////////////////////////////////////////////////
